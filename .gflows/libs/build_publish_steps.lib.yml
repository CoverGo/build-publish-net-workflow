#@ load("@ytt:data", "data")
#@ load("@ytt:struct", "struct")
#@ load("naming.lib.yml", "job")
#@ load("tagging.lib.yml", "tagging")
#@ load("steps.lib.yml", "steps")
#@ load("configuration.lib.yml", "cfg")

---
#@ def _get_compose_service_name_filter_to_diagnose(integration_test_component) :
#@ return "name=" + getattr(integration_test_component,"diagnostic_filter", "*")
#@ end
---
#@ def _compose_launch_steps(integration_test_definition, images, candidate_images):
    - name: Prepare compose file
      uses: ./.github/actions/set-compose-tags
      with:
        images: #@ images
        target-tag: ${{ needs.version.outputs.app_version }}
        compose-file: #@ integration_test_definition.compose_file
    - name: Prepare compose file
      uses: ./.github/actions/set-compose-tags
      with:
        images: #@ candidate_images
        target-tag: candidate-${{ needs.version.outputs.app_version }}
        compose-file: #@ integration_test_definition.compose_file
    - name: #@ "Run {}".format(integration_test_definition.name)
      uses: ./.github/actions/run-in-compose
      with:
        compose-file: #@ integration_test_definition.compose_file
        service-name: #@ getattr(integration_test_definition,"compose_service_name",integration_test_definition.slug)
        project-name: integration-test
        env-vars: '{"GOOGLE_APPLICATION_CREDENTIALS":"${{ secrets.GOOGLE_APPLICATION_CREDENTIALS }}"}'
#@ end
---
#@ def _collect_results_step(integration_test_definition, filter):
name: #@ "Collect {} results".format(integration_test_definition.name)
if: always()
uses: ./.github/actions/docker-extract
with:
  filter: #@ "ancestor="+filter
  container-path: #@ integration_test_definition.container_result_path
  host-path: #@ cfg.get_host_path_for_docker_extract(integration_test_definition)
#@ end

---
#@ def _upload_artifacts_step(path, artifact_name, step_name = None, ifExpression = "always()"):
#@ if step_name == None:
    #@ step_name = "Upload {} as artifact".format(artifact_name)
#@ end
name: #@ step_name
if: #@ ifExpression
uses: actions/upload-artifact@v4
with:
  name: #@ artifact_name
  path: #@ path
  include-hidden-files: true
#@ end
---
#@ def _publish_test_result_as_check_step(filePath, check_name):
name: #@ "Publish {} results as check".format(check_name)
if: always()
env:
  CHECK_NAME: #@ "{} check".format(check_name)
  FILE_PATH: #@ "{}".format(filePath)
run: |
  RETRY_COUNT=0
  MAX_RETRIES=3
  BACKOFF=10

  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    # Check GitHub Rate Limit
    REMAINING=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit | jq '.rate.remaining')
    if [ "$REMAINING" -lt 100 ]; then
      echo "API rate limit is too low: $REMAINING remaining requests. Retrying in $BACKOFF seconds..."
      sleep $BACKOFF
      BACKOFF=$((BACKOFF * 2))
      RETRY_COUNT=$((RETRY_COUNT + 1))
      continue
    fi

    # Publish test results as check
    docker run --rm -v $PWD:/workspace -e GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }} ghcr.io/enricomi/publish-unit-test-result-action \
      --check_name "$CHECK_NAME" \
      --report_individual_runs "true" \
      --files "$FILE_PATH"

    # Check if publishing succeeded
    if [ $? -eq 0 ]; then
      echo "Test results published successfully!"
      break
    else
      echo "Failed to publish test results. Retrying in $BACKOFF seconds..."
      sleep $BACKOFF
      BACKOFF=$((BACKOFF * 2))
      RETRY_COUNT=$((RETRY_COUNT + 1))
    fi

    if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
      echo "Max retries reached. Failing the job."
      exit 1
    fi
  done
#@ end
---
#@ def _copy_between_registries_step(tag_from, tag_to, target_registry_name):
name: #@ "Push Image to {}".format(target_registry_name)
uses: akhilerm/tag-push-action@v2.1.0
with:
  src: #@ tag_from
  #docker.io/user/app:1.0.0
  dst: #@ tag_to
#      quay.io/user/app:latest
#      quay.io/user/app:1.0.0
#      ghcr.io/user/app:latest
#      ghcr.io/user/app:1.0.0
#@ end
---
#@ def _setup_cosign():
name: Set up sigstore cosign
uses: sigstore/cosign-installer@main
#@ end
---
#@ def _sign_container_with_cosign(image_name, image_digest):
name: Sign published container image
run: #@ "cosign sign --key env://COSIGN_PRIVATE_KEY {0}@{1}".format(image_name, image_digest)
env:
  COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
  COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
#@ end
---
#@ bpsteps = struct.make(
#@ compose_launch_steps = _compose_launch_steps,
#@ collect_results_step =  _collect_results_step,
#@ upload_artifacts_step = _upload_artifacts_step,
#@ publish_test_result_as_check_step = _publish_test_result_as_check_step,
#@ copy_between_registries_step = _copy_between_registries_step,
#@ get_compose_service_name_filter_to_diagnose = _get_compose_service_name_filter_to_diagnose,
#@ setup_cosign = _setup_cosign,
#@ sign_container_with_cosign = _sign_container_with_cosign)
