#@ load("@ytt:data", "data")
#@ load("workflows.lib.yml", "get_runner")
#@ load("workflows.lib.yml", "checkout")
#@ load("workflows.lib.yml", "checkout_private_actions")
#@ load("workflows.lib.yml", "login_docker")
#@ load("workflows.lib.yml", "tag_cache")
#@ load("workflows.lib.yml", "docker_build_job_name")
#@ load("workflows.lib.yml", "job_name_from_slug")
#@ load("workflows.lib.yml", "build_and_push_docker")
#@ load("workflows.lib.yml", "generate_diagnostic_password")
#@ load("workflows.lib.yml", "get_timeout")
#@ load("workflows.lib.yml", "get_compose_service_name_filter_to_diagnose")
---
#@ def set_version(context):
#@ if hasattr(context, "versioning"):
#@ if hasattr(context.versioning,"use_branch_slug"):
#@ if not context.versioning.use_branch_slug:
#@ return "none"
#@ end 
#@ end
#@ end
#@ return "${{ steps.issue-key.outputs.issue_id_slug }}"
#@ end

#@ def set_build_number(context):
#@ if hasattr(context, "versioning"):
#@ if hasattr(context.versioning,"use_build_number"):
#@ if context.versioning.use_build_number:
#@ return "${{ github.run_number }}"
#@ end 
#@ end
#@ end
#@ return "none"
#@ end

#@ def get_repository_built_images(settings):
#@ images = []
#@ images.append(get_image_from_section(settings,"service"))
#@ images.extend(get_images_from_section(settings,"unit_test"))
#@ images.extend(get_images_from_section(settings,"integration_test"))
#@ images.extend(get_images_from_section(settings,"additional_images"))
#@ return ';'.join(images)
#@ end

#@ def get_images_from_section(settings,section_name):
#@ images = []
#@ if hasattr(settings, section_name):
#@    for section_item in getattr(settings, section_name):
#@       images.append(getattr(section_item,"image_name",None))
#@    end
#@ end
#@ return images
#@ end

#@ def get_image_from_section(settings, section_name):
#@ section = getattr(settings, section_name,None)
#@ return getattr(section,"image_name",None)
#@ end

#@ def integration_test_steps(integration_test_definition, repository_built_images, cache_registry, main_registry=None, needs= [], default_timeout_component=None):
  runs-on: #@ get_runner(integration_test_definition)
  name: #@ "Run {}".format(integration_test_definition.name)
  timeout-minutes: #@ get_timeout(integration_test_definition,default_timeout_component)
  needs:
    - docker-build-service
    - version
    #@ for need in needs:
    - #@ need
    #@ end
  env:
    RESULTS_PATH: TestResults
  steps:
    - #@ checkout()
    - #@ checkout_private_actions()
    #@ if (main_registry != None):
    - #@ login_docker(main_registry)
    #@ end
    - #@ login_docker(cache_registry)
    - name: Prepare compose file
      uses: ./.github/actions/set-compose-tags
      with:
        images: #@ repository_built_images
        target-tag: ${{ needs.version.outputs.issue_id_slug }}
        compose-file: #@ integration_test_definition.compose_file
    - name: #@ "Run {}".format(integration_test_definition.name)
      uses: ./.github/actions/run-in-compose
      with:
        compose-file: #@ integration_test_definition.compose_file
        service-name: #@ getattr(integration_test_definition,"compose_service_name",integration_test_definition.slug)
        project-name: integration-test

    - name: #@ "Collect {} results".format(integration_test_definition.name)
      if: always()
      uses: ./.github/actions/docker-extract
      with:
        filter: #@ "ancestor="+tag_cache(cache_registry, integration_test_definition)
        container-path: #@ integration_test_definition.container_result_path
        host-path: ./TestResults
    - name: Gather test environment logs
      if: always()
      uses: ./.github/actions/docker-diagnose
      with:
        filter: #@ get_compose_service_name_filter_to_diagnose(integration_test_definition)
        diagnostic-result-path: investigate
        include-compose: true
        encrypt-password: #@ generate_diagnostic_password(integration_test_definition)
        compose-file: #@ integration_test_definition.compose_file
    - name: Upload environment logs as artifact
      if: always()
      uses: actions/upload-artifact@v2
      with:
        name: #@ "{} environment diagnostics".format(integration_test_definition.name)
        path: investigate/*
    - name: #@ "Upload {} results as artifact".format(integration_test_definition.name)
      uses: actions/upload-artifact@v2
      if: always()
      with:
        name: #@ "{} results".format(integration_test_definition.name)
        path: ${{ env.RESULTS_PATH }}
    #@ if getattr(integration_test_definition,"enable_junit_test_check",True) :
    - name: #@ "Publish {} results as check".format(integration_test_definition.name)
      uses: docker://ghcr.io/enricomi/publish-unit-test-result-action:latest
      if: always()
      with:
        report_individual_runs: "true"
        check_name: #@ "{} check".format(integration_test_definition.name)
        github_token: ${{ secrets.GITHUB_TOKEN }}
        files: #@ "TestResults/{}".format(getattr(integration_test_definition,"junit_result_filename","TestResults.xml"))
    #@ end
    #@ if hasattr(integration_test_definition,"cucumber_result_filename") :
    - name: #@ "Upload {} results to Behave.Pro".format(integration_test_definition.name)
      if: always()
      env:
        behave_api_key: ${{ secrets.BEHAVE_PRO_TOKEN }}
        build_id: ${{ github.run_id }}
        build_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        results_file: #@ "${{ env.RESULTS_PATH }}/"+getattr(integration_test_definition,"cucumber_result_filename")
      run: |
        latest_commit_sha=$(git rev-parse HEAD)
        echo "commit sha: $latest_commit_sha"
        echo "test result file: $results_file"
        curl -L -X PUT https://test-reports.behave.pro/REST/1.0/bdd/report \
        -H "X-API-KEY: $behave_api_key" \
        -H "X-COMMIT-ID: $latest_commit_sha" \
        -H "X-BUILD-ID: $build_id" \
        -H "X-BUILD-URL: $build_url" \
        --data-binary @"$results_file" \
    - name: #@ "Publish {} results as check".format(integration_test_definition.name)
      uses: deblockt/cucumber-report-annotations-action@v1.7
      if: always()
      with:
        name: #@ "{} check".format(integration_test_definition.name)
        access-token: ${{ secrets.GITHUB_TOKEN }}
        path: #@ "${{ env.RESULTS_PATH }}/"+getattr(integration_test_definition,"cucumber_result_filename")
    #@ end
#@ end

#@ def get_integration_test_run_job_name(integration_test_definition):
#@ return job_name_from_slug(integration_test_definition,"run-")
#@ end
  
#@ def get_integration_tests_build_jobs(integration_tests):
#@ jobs = []
#@ for integration_test_definition in integration_tests:
#@   jobs.append(docker_build_job_name(integration_test_definition))
#@ end
#@ return jobs
#@ end


#@ def get_integration_tests_run_jobs(integration_tests):
#@ jobs = []
#@ for integration_test_definition in integration_tests:
#@   jobs.append(get_integration_test_run_job_name(integration_test_definition))
#@ end
#@ return jobs
#@ end

#@ def get_additional_images_build_jobs(additional_images):
#@ jobs = []
#@ for additional_image in additional_images:
#@   jobs.append(docker_build_job_name(additional_image))
#@ end
#@ return jobs
#@ end


---

#@ def get_unit_test_job_name(unit_test_definition):
#@ return job_name_from_slug(unit_test_definition,"build-and-run-")
#@ end

#@ def get_unit_tests_job_names(unit_tests):
#@ jobs = []
#@ for unit_test_definition in unit_tests:
#@   jobs.append(get_unit_test_job_name(unit_test_definition))
#@ end
#@ return jobs
#@ end

  
#@ def unit_test_build_and_run_steps(unit_test_definition,cache_registry,default_timeout_component = None):
    name: #@ "Build and run {}".format(unit_test_definition.name, cache_registry)
    runs-on: ubuntu-latest
    timeout-minutes: #@ get_timeout(unit_test_definition,default_timeout_component)
    env:
      RESULTS_PATH: TestResults
      UNIT_TEST_IMAGE_TAG: #@ tag_cache(cache_registry, unit_test_definition)
    needs:
      - version
    steps:
      - #@ build_and_push_docker(unit_test_definition, cache_registry, step_name="Load {} image into local docker".format(unit_test_definition.name), load_image=True, push_image=False)
      - name: #@ "Run {}".format(unit_test_definition.name)
        run: |
          id=$(docker images "$UNIT_TEST_IMAGE_TAG" -q | head -n 1)
          echo "found image id: $id"
          docker run --name unit_tests $id
      - #@ checkout_private_actions()
      - name: #@ "Get {} results".format(unit_test_definition.name)
        if: always()
        uses: ./.github/actions/docker-extract
        with:
          filter: ancestor=$UNIT_TEST_IMAGE_TAG
          container-path: #@ unit_test_definition.container_result_path
          host-path: ./TestResults
      - name: #@ "Upload {} results as artifact".format(unit_test_definition.name)
        uses: actions/upload-artifact@v2
        if: always()
        with:
          name: #@ "{} results".format(unit_test_definition.name)
          path: ${{ env.RESULTS_PATH }}
      - name: #@ "Publish {} results as Check".format(unit_test_definition.name)
        uses: docker://ghcr.io/enricomi/publish-unit-test-result-action:latest
        if: always()
        with:
          report_individual_runs: "true"
          check_name: #@ "{} Results".format(unit_test_definition.name)
          github_token: ${{ secrets.GITHUB_TOKEN }}
          files: ${{ env.RESULTS_PATH }}/**/*.xml  
#@ end