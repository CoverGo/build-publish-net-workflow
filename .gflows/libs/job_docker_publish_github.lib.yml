#@ load("@ytt:data", "data")

#@ load("job_docker_build.lib.yml", "docker")
#@ load("naming.lib.yml", "job")
#@ load("job_dependency_resolution.lib.yml", "dep")
#@ load("build_publish_steps.lib.yml", "bpsteps")
#@ load("steps.lib.yml", "steps")
#@ load("common.lib.yml", "common")
#@ load("tagging.lib.yml", "tagging")

---
#@ def generate_docker_publish_github(sections, tags_from):
#@ name= "Publish {} to GitHub".format(sections.service.name)
#@ needs=["version", job.id.docker_build(sections.service)]
#@ if hasattr(sections,"integration_test"):
#@ needs.extend(dep.get_integration_tests_run_jobs(sections.integration_test))
#@ end

#@ if hasattr(sections,"unit_test"):
#@ needs.extend(dep.get_unit_tests_job_names(sections.unit_test))
#@ end

#@ if (hasattr(sections,"integration_tests_legacy")):
#@ needs.append("integration-tests-legacy-small")
#@ needs.append("integration-tests-legacy-big")
#@ end

#@ steps = generate_docker_publish_github_steps(sections)
#@ return common.generate_job(sections.service, steps, None, sections, needs, "Tag service image an GitHub")
#@ end
---
#@ def generate_docker_publish_github_steps(sections):
- #@ steps.login_docker(sections.cache_registry)
- #@ bpsteps.copy_between_registries_step(tagging.candidate_image(sections.cache_registry, sections.service),"${{ needs.version.outputs.docker_image_ghcr_tags }}",sections.cache_registry.name)
- #@ bpsteps.setup_cosign()
- #@ bpsteps.sign_container_with_cosign(tagging.with_registry(sections.cache_registry.url,sections.service.image_name,"${{ needs.version.outputs.app_version }}"), "${{ needs." + job.id.docker_build(data.values.service) + ".outputs.digest }}")
#@ end
---
